import { ethers } from 'ethers';
import { config } from '../config';
import { logger } from '../utils/logger';
import { BlockchainTransaction, ContractCallOptions } from '../types';

// Import contract ABIs (these would be generated by typechain)
import { NILVault__factory, ComplianceRegistry__factory, ContractNFT__factory } from '../../typechain-types';

class BlockchainService {
  private provider: ethers.providers.JsonRpcProvider;
  private signer: ethers.Wallet;
  private nilVaultFactory: ethers.ContractFactory;
  private complianceRegistry: ethers.Contract;
  private contractNFT: ethers.Contract;

  constructor() {
    // Initialize provider based on environment
    const networkConfig = this.getNetworkConfig();
    this.provider = new ethers.providers.JsonRpcProvider(networkConfig.url);
    
    // Initialize signer
    this.signer = new ethers.Wallet(config.blockchain.privateKey, this.provider);
    
    // Initialize contract factories and instances
    this.nilVaultFactory = new NILVault__factory(this.signer);
    
    this.complianceRegistry = ComplianceRegistry__factory.connect(
      config.contracts.complianceRegistry,
      this.signer
    );
    
    this.contractNFT = ContractNFT__factory.connect(
      config.contracts.contractNFT,
      this.signer
    );
  }

  /**
   * Deploy NIL vault for athlete
   */
  async deployNILVault(athleteData: any): Promise<string> {
    try {
      logger.info(`Deploying NIL vault for athlete: ${athleteData.name}`);

      // Deploy new vault contract
      const vault = await this.nilVaultFactory.deploy(
        athleteData.walletAddress,
        ethers.constants.AddressZero, // NIL protocol address
        config.contracts.complianceRegistry,
        this.getGasOptions()
      );

      await vault.deployed();
      logger.info(`NIL vault deployed at: ${vault.address}`);

      // Setup athlete profile on the vault
      const tx = await vault.setupAthleteProfile(
        athleteData.name,
        athleteData.sport,
        athleteData.school || 'Independent',
        ethers.utils.keccak256(ethers.utils.toUtf8Bytes('kyc_pending')),
        this.getGasOptions()
      );

      await tx.wait();
      logger.info(`Athlete profile setup completed for vault: ${vault.address}`);

      return vault.address;
    } catch (error) {
      logger.error('Error deploying NIL vault:', error);
      throw error;
    }
  }

  /**
   * Get vault information
   */
  async getVaultInfo(vaultAddress: string): Promise<any> {
    try {
      const vault = NILVault__factory.connect(vaultAddress, this.provider);
      
      const [
        athleteProfile,
        totalEarnings,
        dealHistory,
        balance
      ] = await Promise.all([
        vault.athleteProfile(),
        vault.getTotalEarnings(),
        vault.getAllDeals(),
        this.provider.getBalance(vaultAddress)
      ]);

      return {
        athleteProfile: {
          name: athleteProfile.name,
          sport: athleteProfile.sport,
          school: athleteProfile.school,
          eligibilityStatus: athleteProfile.eligibilityStatus,
          verified: athleteProfile.verified,
          totalEarnings: athleteProfile.totalEarnings.toString(),
          activeDeals: athleteProfile.activeDeals.toString(),
        },
        totalEarnings: totalEarnings.toString(),
        dealCount: dealHistory.length,
        balance: balance.toString(),
      };
    } catch (error) {
      logger.error('Error getting vault info:', error);
      throw error;
    }
  }

  /**
   * Create NIL deal on blockchain
   */
  async createNILDeal(
    vaultAddress: string,
    dealData: any,
    options?: ContractCallOptions
  ): Promise<BlockchainTransaction> {
    try {
      const vault = NILVault__factory.connect(vaultAddress, this.signer);

      // Convert revenue splits to basis points
      const revenueSplits = [
        Math.floor(dealData.revenueSplits.athlete * 100),
        Math.floor(dealData.revenueSplits.school * 100),
        Math.floor(dealData.revenueSplits.collective * 100),
        Math.floor(dealData.revenueSplits.platform * 100),
      ];

      const tx = await vault.createNILDeal(
        dealData.brandAddress,
        ethers.utils.parseEther(dealData.amount.toString()),
        dealData.deliverables.join(', '),
        dealData.termsIPFS || '',
        revenueSplits,
        dealData.beneficiaries,
        { ...this.getGasOptions(), ...options }
      );

      const receipt = await tx.wait();
      
      return {
        hash: receipt.transactionHash,
        blockNumber: receipt.blockNumber,
        gasUsed: receipt.gasUsed.toNumber(),
        status: receipt.status === 1 ? 'success' : 'failed',
        events: receipt.events || [],
      };
    } catch (error) {
      logger.error('Error creating NIL deal:', error);
      throw error;
    }
  }

  /**
   * Execute NIL deal
   */
  async executeNILDeal(
    vaultAddress: string,
    dealId: string,
    options?: ContractCallOptions
  ): Promise<BlockchainTransaction> {
    try {
      const vault = NILVault__factory.connect(vaultAddress, this.signer);
      
      const tx = await vault.executeNILDeal(
        dealId,
        { ...this.getGasOptions(), ...options }
      );

      const receipt = await tx.wait();
      
      return {
        hash: receipt.transactionHash,
        blockNumber: receipt.blockNumber,
        gasUsed: receipt.gasUsed.toNumber(),
        status: receipt.status === 1 ? 'success' : 'failed',
        events: receipt.events || [],
      };
    } catch (error) {
      logger.error('Error executing NIL deal:', error);
      throw error;
    }
  }

  /**
   * Update KYC information on blockchain
   */
  async updateKYC(
    athleteAddress: string,
    kycData: any
  ): Promise<BlockchainTransaction> {
    try {
      const tx = await this.complianceRegistry.verifyKYC(
        athleteAddress,
        kycData.verificationLevel,
        kycData.jurisdiction,
        kycData.documentHash,
        kycData.expiryTimestamp,
        this.getGasOptions()
      );

      const receipt = await tx.wait();
      
      return {
        hash: receipt.transactionHash,
        blockNumber: receipt.blockNumber,
        gasUsed: receipt.gasUsed.toNumber(),
        status: receipt.status === 1 ? 'success' : 'failed',
        events: receipt.events || [],
      };
    } catch (error) {
      logger.error('Error updating KYC:', error);
      throw error;
    }
  }

  /**
   * Check deal compliance
   */
  async checkDealCompliance(
    dealId: string,
    athleteAddress: string,
    brandAddress: string,
    amount: string,
    jurisdiction: string
  ): Promise<boolean> {
    try {
      const result = await this.complianceRegistry.checkDealCompliance(
        dealId,
        athleteAddress,
        brandAddress,
        ethers.utils.parseEther(amount),
        jurisdiction,
        this.getGasOptions()
      );

      const receipt = await result.wait();
      const complianceEvent = receipt.events?.find(e => e.event === 'DealComplianceChecked');
      
      return complianceEvent?.args?.approved || false;
    } catch (error) {
      logger.error('Error checking deal compliance:', error);
      throw error;
    }
  }

  /**
   * Mint contract NFT
   */
  async mintContractNFT(contractData: any): Promise<BlockchainTransaction> {
    try {
      // Convert revenue splits to basis points
      const revenueSplits = contractData.revenueSplits.map((split: number) => Math.floor(split * 100));

      const tx = await this.contractNFT.mintContract(
        contractData.athleteVault,
        contractData.brandAddress,
        ethers.utils.parseEther(contractData.amount.toString()),
        contractData.deliverables,
        contractData.termsIPFS,
        contractData.jurisdiction,
        contractData.platformSource,
        revenueSplits,
        contractData.beneficiaries,
        this.getGasOptions()
      );

      const receipt = await tx.wait();
      
      return {
        hash: receipt.transactionHash,
        blockNumber: receipt.blockNumber,
        gasUsed: receipt.gasUsed.toNumber(),
        status: receipt.status === 1 ? 'success' : 'failed',
        events: receipt.events || [],
      };
    } catch (error) {
      logger.error('Error minting contract NFT:', error);
      throw error;
    }
  }

  /**
   * Authorize platform to create deals
   */
  async authorizePlatform(
    vaultAddress: string,
    platformAddress: string
  ): Promise<BlockchainTransaction> {
    try {
      const vault = NILVault__factory.connect(vaultAddress, this.signer);
      
      const tx = await vault.addAuthorizedPlatform(
        platformAddress,
        this.getGasOptions()
      );

      const receipt = await tx.wait();
      
      return {
        hash: receipt.transactionHash,
        blockNumber: receipt.blockNumber,
        gasUsed: receipt.gasUsed.toNumber(),
        status: receipt.status === 1 ? 'success' : 'failed',
        events: receipt.events || [],
      };
    } catch (error) {
      logger.error('Error authorizing platform:', error);
      throw error;
    }
  }

  /**
   * Remove platform authorization
   */
  async deauthorizePlatform(
    vaultAddress: string,
    platformAddress: string
  ): Promise<BlockchainTransaction> {
    try {
      const vault = NILVault__factory.connect(vaultAddress, this.signer);
      
      const tx = await vault.removeAuthorizedPlatform(
        platformAddress,
        this.getGasOptions()
      );

      const receipt = await tx.wait();
      
      return {
        hash: receipt.transactionHash,
        blockNumber: receipt.blockNumber,
        gasUsed: receipt.gasUsed.toNumber(),
        status: receipt.status === 1 ? 'success' : 'failed',
        events: receipt.events || [],
      };
    } catch (error) {
      logger.error('Error removing platform authorization:', error);
      throw error;
    }
  }

  /**
   * Monitor blockchain events
   */
  async startEventMonitoring(): Promise<void> {
    logger.info('Starting blockchain event monitoring...');

    // Listen for NIL deal events across all vaults
    this.provider.on({
      topics: [
        ethers.utils.id('NILDealCreated(bytes32,address,address,uint256,string)')
      ]
    }, (log) => {
      this.handleNILDealCreated(log);
    });

    // Listen for compliance events
    this.complianceRegistry.on('DealComplianceChecked', (dealId, athleteVault, approved, reason, timestamp) => {
      this.handleComplianceChecked(dealId, athleteVault, approved, reason, timestamp);
    });

    // Listen for contract NFT minting
    this.contractNFT.on('ContractMinted', (tokenId, athleteVault, brand, amount, platformSource) => {
      this.handleContractMinted(tokenId, athleteVault, brand, amount, platformSource);
    });
  }

  /**
   * Get current gas price
   */
  async getGasPrice(): Promise<ethers.BigNumber> {
    try {
      const gasPrice = await this.provider.getGasPrice();
      return gasPrice.mul(110).div(100); // Add 10% buffer
    } catch (error) {
      logger.error('Error getting gas price:', error);
      return ethers.utils.parseUnits('20', 'gwei'); // Fallback to 20 gwei
    }
  }

  /**
   * Estimate gas for transaction
   */
  async estimateGas(
    contract: ethers.Contract,
    methodName: string,
    params: any[]
  ): Promise<ethers.BigNumber> {
    try {
      const gasEstimate = await contract.estimateGas[methodName](...params);
      return gasEstimate.mul(120).div(100); // Add 20% buffer
    } catch (error) {
      logger.error('Error estimating gas:', error);
      return ethers.BigNumber.from(500000); // Fallback gas limit
    }
  }

  // Private helper methods
  private getNetworkConfig() {
    const networkName = config.nodeEnv === 'production' ? 'mainnet' : 'polygon';
    return config.blockchain.networks[networkName as keyof typeof config.blockchain.networks];
  }

  private getGasOptions(): ContractCallOptions {
    return {
      gasPrice: config.blockchain.gasPrice.standard,
      gasLimit: 500000, // Default gas limit
    };
  }

  // Event handlers
  private async handleNILDealCreated(log: any): Promise<void> {
    try {
      logger.info('NIL Deal Created event detected:', log);
      
      // Decode event data
      const iface = new ethers.utils.Interface([
        'event NILDealCreated(bytes32 indexed dealId, address indexed athlete, address indexed brand, uint256 amount, string deliverables)'
      ]);
      
      const decoded = iface.parseLog(log);
      
      // Here you would update your database with the new deal
      // and trigger any necessary business logic
      logger.info('Processed NIL Deal Created:', {
        dealId: decoded.args.dealId,
        athlete: decoded.args.athlete,
        brand: decoded.args.brand,
        amount: decoded.args.amount.toString(),
      });
    } catch (error) {
      logger.error('Error handling NIL Deal Created event:', error);
    }
  }

  private async handleComplianceChecked(
    dealId: string,
    athleteVault: string,
    approved: boolean,
    reason: string,
    timestamp: number
  ): Promise<void> {
    try {
      logger.info('Compliance Checked event:', {
        dealId,
        athleteVault,
        approved,
        reason,
        timestamp,
      });
      
      // Update database with compliance status
    } catch (error) {
      logger.error('Error handling Compliance Checked event:', error);
    }
  }

  private async handleContractMinted(
    tokenId: ethers.BigNumber,
    athleteVault: string,
    brand: string,
    amount: ethers.BigNumber,
    platformSource: string
  ): Promise<void> {
    try {
      logger.info('Contract NFT Minted:', {
        tokenId: tokenId.toString(),
        athleteVault,
        brand,
        amount: amount.toString(),
        platformSource,
      });
      
      // Update database with NFT information
    } catch (error) {
      logger.error('Error handling Contract Minted event:', error);
    }
  }
}

export const blockchainService = new BlockchainService();